# Code Owner Finder
При работе с большими кодовыми базами часто удобно знать, кто лучше всех разбирается
в содержимом конкретного файла. С одной стороны, это может быть человек, который
написал в этом файле больше всего кода. С другой, особенно если файл существует
достаточно давно, может случиться так, что исходный автор долго этого кода не касался
и уже мог всё забыть. Наверняка тот, кто с этим кодом работал недавно, но при этом
сделал достаточно значительный вклад, может дать более актуальную информацию.
Будем называть такого человека владельцем кода (code owner).

Code Owner Finder — это плагин к IntelliJ IDEA, который по данным системы
контроля версий оценивает вклад каждого коммиттера в выбранный файл и выдаёт рекомендацию 
— список тех, кто, предполагаемо, больше всех знаком с содержимом выбранного файла.

## Использование
После установки плагина щелкните ПКМ на любой файл (не директорию), и выберите `Find Code Owner...`

## Данные, подаваемые на вход алгоритму
* Совокупность данных выбранного файла, на основе которых вычисляется владелец, отражена в классе `DiffHistory`. В нём хранятся данные о всех версиях файла.
* Для каждой версии файла (класс `DiffRevision`) хранятся данные о каждой строке версии (класс `DiffLine`) и об изменениях (класс `Difference`), которые отличают эту версию от предыдущей.
* О каждой строке мы знаем её дату создания, её автора и её *вес*. *Вес* — это некоторое число, которое отражает содержательность данной строки относительно других строк файла. Необходимость подсчёта веса обусловлена тем, что не все строки вносят одинаковый смысловой вклад в файл (если разработчик добавил несколько пустых строк и только, то его вклад не должен быть значительным). Вес можно считать по-разному (алгоритм подсчёта веса должен реализовывать интерфейс `LineWeightCalculator`). Текущий алгоритм считает количество "слов" (см. `WordLineWeightCalculator`).
* Разность между версиями (класс `Difference`) представляет собой список изменений вида "такие-то строки удалены" и "такие-то строки добавлены" (см. класс `DiffChange`). Также хранится дата и автор этого изменения.

## Алгоритм 
* Алгоритм вычисляет для каждого разработчика (независимо от других) величину, называемую *уровнем знания* файла. *Уровень знания* — это доля содержимого файла, которую понимает разработчик на данный момент времени (число от 0 до 1). 
* Уровень знания целого файла получается из уровней знания каждой строки в файле. Класс `KnowledgeState` описывает состояние понимания файла разработчиком на определенную дату: для каждой строки вместе с весом (и прочим) хранится уровень знания этой строки. Тогда уровень знания файла логично рассчитать ровно как долю всего файла, которую разработчик понимает: это равно отношению линейной комбинации уровней знания строк с их весами к сумме весов всех строк. См. класс `KnowledgeState`.
* Состояние знания файла меняется с течением времени разными способами в зависимости от случая. Вычисление нового состояния происходит в классе, который реализует интерфейс `KnowledgeStateCalculator`.
  - Случай A: с течением времени никакие коммиты не происходят. Тогда разработчик со временем должен забывать содержимое файла. Как именно он забывает код, рассчитывается классом, реализующим интерфейс `OblivionFunction`. Основная реализация "функции забвения" — убывающая экспонента: за ровно `OblivionFunctionImpl.HALF_LIFE_IN_DAYS` дней разработчик забывает половину того, чего он знает. Действительно можно считать, что чем больше прошло времени, тем медленнее разработчик забывает код. Это можно обосновать тем, что большая часть памяти о коде недолговременна, и только лишь некоторые вещи впадают в долговременную память.
  - Случай B: разработчик сам совершил коммит. Тогда добавленные строки разработчик знает полностью (уровень их знания равен 1), а также он теперь лучше знает строки в окрестности добавленных. Как именно распространяется знание на окрестности, рассчитывается классом, реализующим интерфейс `LineKnowledgeAdder`. В текущем варианте знание добавленной строки пропорционально весу распространяется в обе стороны как линейная убывающая функция. Стоит отметить, что знание действует не на строки, а на единицы веса.
  - Случай C: был совершен коммит иным разработчиком. В таком случае, новые добавленные строки разработчик вообще не знает (уровень знания 0), а уровень знания остальных строк не меняется.
* Наконец, по актуальному состоянию знания файла на сегодняшний день рассчитывается уровень знания целого файла. После этого разработчики упорядочиваются по уровню знания, и берутся несколько с самым большим уровнем.